为了成为一名合格的android开发者,今天起开始坚持记录学习笔记.

android框架:
1.OkHttp:
	基本使用-http://blog.csdn.net/iispring/article/details/51661195
	官方文档-https://github.com/square/okhttp/wiki/Calls
	基本原理分析-http://blog.csdn.net/evan_man/article/details/51173810
			   -http://blog.csdn.net/evan_man/article/details/51180863
			   -http://blog.csdn.net/evan_man/article/details/51182087
			   -http://blog.csdn.net/evan_man/article/details/51204469
2.Xutils:
	基本使用-http://blog.csdn.net/true100/article/details/51734217
	官方示例-见github


疑难小问题:
1.retrofit使用post把数据传给服务端时出现中文乱码的问题
解决方案-添加头部如下:
@Headers("Content-Type:application/x-www-form-urlencoded; charset=utf-8")

2.在浏览其查看android内部数据：
debugCompile 'com.amitshekhar.android:debug-db:1.0.0'

3.在使用xutils操作数据库的时候，bean必须加上空构造函数，否则不能创建数据库。

4.在使用xutils绑定view的时候，方法名必须是private的，否则绑定不了view。

5.实现聊天界面的时候，使用recyclerview显示消息列表，当打开输入法的时候，recyclerview并不能滑动到底部。
解决方案：mLayoutManager.setStackFromEnd(true);

6.android api>=24的手机拍照问题解决方案：
a.mainifest配置如下：
<!--当TARGET_SDK >= 24的时候需要使用file provider访问文件-->
<provider
            android:name=".app.MyFileProvider"
            android:authorities="com.jicq.provider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/provider_paths" />
        </provider>
b.@xml/provider_paths文件内容如下：
<?xml version="1.0" encoding="utf-8"?>
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <external-path
        name="external_files"
        path="." />
</paths>
c. .app.MyFileProvider文件内容如下：
import android.support.v4.content.FileProvider;
public class MyFileProvider extends FileProvider {

}
d.代码书写：
private void takePicture() {
        mCurrentPicName = System.currentTimeMillis() + ".png";
        File currentPic = new File(mLogDirectory, mCurrentPicName);
        Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
        Uri imageUri;
        if (Build.VERSION.SDK_INT >= 24) {
            imageUri = FileProvider.getUriForFile(this,
                    "com.jicq.provider", currentPic);
            intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
        } else {
            imageUri = Uri.fromFile(currentPic);
        }
        intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);
        startActivityForResult(intent, REQUEST_CODE_CAPTURE);
}
相应的打开图片浏览器：
/***
     * 打开系统自带的图片浏览器，进行图片浏览操作。
     * @param picPath 图片的绝对路径。
     */
    private void openImageBrowser(String picPath) {
        if (Build.VERSION.SDK_INT < 24) {
            Uri imageUri;
            if (picPath.startsWith("content://")) {
                imageUri = Uri.parse(picPath);
            } else {
                imageUri = Uri.parse("file://" + picPath);
            }
            Intent intent = new Intent(Intent.ACTION_VIEW);
            intent.setDataAndType(imageUri, "image/*");
            startActivity(intent);
        } else {
            Intent intent = new Intent(Intent.ACTION_VIEW);
            Uri uri = FileProvider.getUriForFile(this,
                    "com.jicq.provider", new File(picPath));
            intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
            intent.setDataAndType(uri, "image/*");
            startActivity(intent);
        }
    }

7.将相册里的Uri转为String格式的路径
/**
 * 将相册里的Uri转为String格式的路径
 *
 * @param uri 资源定位地址
 * @return String格式路径
 */
private String getPathFromUri(Uri uri) {
    String path = "";
    String[] projection = {MediaStore.Images.Media.DATA};
    ContentResolver resolver = getContentResolver();
    Cursor cursor = resolver.query(uri, projection, null,
            null, null);
    if (cursor != null) {
        cursor.moveToFirst();
        path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA));
        cursor.close();
    }
    return path;
}

8.裁切图片：
/***
 * 构建裁切图片的intent。
 * @param imageUri 要裁切的图片的uri
 * @return
 */

private Intent buildCropIntent(Uri imageUri) {
    File headerFile =
            new File(Environment.getExternalStorageDirectory(), "fh_header.jpg");
    mHeaderPath = headerFile.getAbsolutePath();
    Intent intent = new Intent("com.android.camera.action.CROP");
    intent.setDataAndType(imageUri, "image/*");
    intent.putExtra("crop", "true");
    // 设置x,y的比例，截图方框就按照这个比例来截 若设置为0,0，或者不设置 则自由比例截图
    intent.putExtra("aspectX", 1);
    intent.putExtra("aspectY", 1);
    // 裁剪区的宽和高 其实就是裁剪后的显示区域 若裁剪的比例不是显示的比例，
    // 则自动压缩图片填满显示区域。若设置为0,0 就不显示。若不设置，则按原始大小显示
    intent.putExtra("outputX", 600);
    intent.putExtra("outputY", 600);
    // 不知道有啥用。。可能会保存一个比例值 需要相关文档啊
    intent.putExtra("scale", true);
    // true的话直接返回bitmap，可能会很占内存 不建议
    intent.putExtra("return-data", false);
    // 上面设为false的时候将MediaStore.EXTRA_OUTPUT即"output"关联一个Uri
    intent.putExtra("output", Uri.fromFile(headerFile));
    // 看参数即可知道是输出格式
    intent.putExtra("outputFormat", Bitmap.CompressFormat.JPEG.toString());
    // 面部识别 这里用不上
    intent.putExtra("noFaceDetection", false);
    return intent;
}

9.使用xutils绑定图片的时候，如果设置图片是圆形的，则部分机型会出现黑色背景，解决方案：
在ImageDecoder.java 589行 将thumbBitmap.compress(supportWebP ? Bitmap.CompressFormat.WEBP : Bitmap.CompressFormat.PNG, 80, out); 更改为thumbBitmap.compress( Bitmap.CompressFormat.PNG, 80, out); 即可

